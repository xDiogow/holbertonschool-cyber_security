#!/usr/bin/env ruby

class MetasploitModule < Msf::Auxiliary
  include Msf::Exploit::Remote::Tcp
  include Msf::Auxiliary::Scanner

  def initialize(info = {})
    super(update_info(info,
      'Name'        => 'Custom Port Scanner',
      'Description' => 'This module scans a range of ports on a target system and identifies which ones are open.',
      'Author'      => ['Diogo'],
      'License'     => MSF_LICENSE
    ))

    register_options([
      OptInt.new('STARTPORT', [true, 'The starting port to scan', 20]),
      OptInt.new('ENDPORT',   [true, 'The ending port to scan', 1000]),
      OptInt.new('RPORT',     [false, 'Unused but required by scanner module', 0])
    ])
  end

  def run_host(ip)
    start_port = datastore['STARTPORT']
    end_port = datastore['ENDPORT']

    if (start_port > end_port)
      print_error("STARTPORT must be less than or equal to ENDPORT")
      return
    end

    open_ports = []

    print_status("Running module against #{ip}")

    (start_port..end_port).each do |port|
      begin
        sock = Rex::Socket::Tcp.create(
          'PeerHost' => ip,
          'PeerPort' => port,
          'Context'  => {'Msf' => framework, 'MsfExploit' => self},
          'Timeout'  => 10
        )
        
        if sock
          print_good("#{ip}:#{port} - Port #{port} is open on #{ip}")
          open_ports << port
          sock.close
        end
      rescue Rex::ConnectionRefused, Rex::ConnectionError, Rex::HostUnreachable
        # Port is closed or filtered
      rescue => e
        print_error("Error checking port #{port}: #{e}")
      end
    end

    if open_ports.empty?
      print_status("No open ports found on #{ip}")
    else
      print_status("Open ports on #{ip}: #{open_ports.join(', ')}")
    end
  end
end
